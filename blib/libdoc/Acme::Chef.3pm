.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Acme::Chef 3"
.TH Acme::Chef 3 "2012-04-17" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Acme::Chef \- An interpreter for the Chef programming language
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  # Using the script that comes with the distribution.
\&  chef.pl file.chef
\&
\&  # Using the module
\&  use Acme::Chef;
\&
\&  my $compiled = Acme::Chef\->compile($code_string);
\&  print $compiled\->execute();
\&
\&  my $string = $compiled\->dump(); # requires Data::Dumper
\&  # Save it to disk, send it over the web, whatever.
\&  my $reconstructed_object = eval $string;
\&
\&  # or:
\&  $string = $compiled\->dump(\*(Aqautorun\*(Aq); # requires Data::Dumper
\&  # Save it to disk, send it over the web, whatever.
\&  my $output_of_chef_program = eval $string;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Chef is an esoteric programming language in which programs look like
recipes. I needn't mention that using it in
production environment, heck, using it for anything but entertainment
ought to result in bugs and chaos in reverse order.
.PP
All methods provided by Acme::Chef are adequately described in the
synopsis. If you don't think so, you need to read the source code.
.PP
There has been an update to the Chef specification. I have implemented
the changes and marked them in the following documentation with
"\fInew specification\fR".
.PP
With that out of the way, I would like to present a pod-formatted
copy of the Chef specification from David Morgan-Mar's homepage
(<http://www.dangermouse.net/esoteric/chef.html>).
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
This is a list of methods in this package.
.IP "compile" 2
.IX Item "compile"
Takes Chef source code as first argument and compiles a Chef program from it.
This method doesn't run the code, but returns a program object.
.IP "execute" 2
.IX Item "execute"
Takes no arguments. Runs the program and returns its output.
.IP "dump" 2
.IX Item "dump"
Takes one optional argument. If it equals 'autorun',
dump returns a string that, when evaluated, executes
the program and returns the output.
.Sp
If the argument does not equal 'autorun', a different
string is returned that reconstructs the Acme::Chef
object.
.SH "DESIGN PRINCIPLES"
.IX Header "DESIGN PRINCIPLES"
.IP "\(bu" 2
Program recipes should not only generate valid output, but be easy to
prepare and delicious.
.IP "\(bu" 2
Recipes may appeal to cooks with different budgets.
.IP "\(bu" 2
Recipes will be metric, but may use traditional cooking measures such as
cups and tablespoons.
.SH "LANGUAGE CONCEPTS"
.IX Header "LANGUAGE CONCEPTS"
.SS "Ingredients"
.IX Subsection "Ingredients"
All recipes have ingredients! The ingredients hold individual data values.
All ingredients are numerical, though they can be interpreted as Unicode
for I/O purposes. Liquid ingredients will be output as Unicode characters,
while dry or unspecified ingredients will be output as numbers.
.SS "Mixing Bowls and Baking Dishes"
.IX Subsection "Mixing Bowls and Baking Dishes"
Chef has access to an unlimited supply of mixing bowls and baking dishes.
These can contain ingredient values. The ingredients in a mixing bowl or
baking dish are ordered, like a stack of pancakes. New ingredients are
placed on top, and if values are removed they are removed from the top.
Note that if the value of an ingredient changes, the value in the mixing
bowl or baking dish does not. The values in the mixing bowls and baking
dishes also retain their dry or liquid designations.
.PP
Multiple mixing bowls and baking dishes are referred to by an ordinal
identifier \- \*(L"the 2nd mixing bowl\*(R". If no identifier is used, the recipe
only has one of the relevant utensil. Ordinal identifiers must be digits
followed by \*(L"st\*(R", \*(L"nd\*(R", \*(L"rd\*(R" or \*(L"th\*(R", not words.
.SH "SYNTAX ELEMENTS"
.IX Header "SYNTAX ELEMENTS"
The following items appear in a Chef recipe. Some are optional. Items
must appear in the order shown below, with a blank line (two newlines)
between each item.
.SS "Recipe Title"
.IX Subsection "Recipe Title"
The recipe title describes in a few words what the program does. For
example: \*(L"Hello World Souffle\*(R", or \*(L"Fibonacci Numbers with Caramel Sauce\*(R".
The recipe title is always the first line of a Chef recipe, and is
followed by a full stop.
.PP
.Vb 1
\&  recipe\-title.
.Ve
.SS "Comments"
.IX Subsection "Comments"
Comments are placed in a free-form paragraph after the recipe title.
Comments are optional.
.SS "Ingredient List"
.IX Subsection "Ingredient List"
The next item in a Chef recipe is the ingredient list. This lists the
ingredients to be used by the program. The syntax is
.PP
.Vb 3
\&  Ingredients.
\&  [initial\-value] [[measure\-type] measure] ingredient\-name
\&  [further ingredients]
.Ve
.PP
Ingredients are listed one per line. The intial-value is a number.
\&\fINew specification: The initial-value is now optional. Attempting to
use an ingredient without a defined value is a run-time error.\fR
The optional measure can be any of the following:
.IP "\(bu" 2
\&\f(CW\*(C`g\*(C'\fR | \f(CW\*(C`kg\*(C'\fR | \f(CW\*(C`pinch[es]\*(C'\fR : These always indicate dry measures.
.IP "\(bu" 2
\&\f(CW\*(C`ml\*(C'\fR | \f(CW\*(C`l\*(C'\fR | \f(CW\*(C`dash[es]\*(C'\fR : These always indicate liquid measures.
.IP "\(bu" 2
\&\f(CW\*(C`cup[s]\*(C'\fR | \f(CW\*(C`teaspoon[s]\*(C'\fR | \f(CW\*(C`tablespoon[s]\*(C'\fR : These indicate measures
which may be either dry or liquid.
.PP
The optional measure-type may be any of the following:
.IP "\(bu" 2
\&\f(CW\*(C`heaped\*(C'\fR | \f(CW\*(C`level\*(C'\fR : These indicate that the measure is dry.
.PP
The ingredient-name may be anything reasonable, and may include space
characters. The ingredient list is optional. If present, it declares
ingredients with the given initial values and measures.
.SS "Cooking Time"
.IX Subsection "Cooking Time"
.Vb 1
\&  Cooking time: time (hour[s] | minute[s]).
.Ve
.PP
The cooking time statement is optional. The time is a number.
.SS "Oven Temperature"
.IX Subsection "Oven Temperature"
.Vb 1
\&  Pre\-heat oven to temperature degrees Celcius [(gas mark mark)].
.Ve
.PP
Some recipes require baking. If so, there will be an oven
temperature statement. This is optional. The temperature and mark are
numbers.
.SS "Method"
.IX Subsection "Method"
.Vb 2
\&  Method.
\&  method statements
.Ve
.PP
The method contains the actual recipe instructions. These are written
in sentences. Line breaks are ignored in the method of a recipe. Valid
method instructions are:
.IP "\(bu" 2
\&\f(CW\*(C`Take ingredient from refrigerator.\*(C'\fR
.Sp
\&\fINew specification!\fR This reads lines from \s-1STDIN\s0 until a
numerical value is found. This numerical value is put into the
ingredient overwriting any previous value.
.IP "\(bu" 2
\&\f(CW\*(C`Put ingredient into [nth] mixing bowl.\*(C'\fR
.Sp
This puts the ingredient into the nth mixing bowl.
.IP "\(bu" 2
\&\f(CW\*(C`Fold ingredient into [nth] mixing bowl.\*(C'\fR
.Sp
This removes the top value from the nth mixing bowl and places it in
the ingredient.
.IP "\(bu" 2
\&\f(CW\*(C`Add ingredient [to [nth] mixing bowl].\*(C'\fR
.Sp
This adds the value of ingredient to the value of the ingredient on top
of the nth mixing bowl and stores the result in the nth mixing bowl.
.IP "\(bu" 2
\&\f(CW\*(C`Remove ingredient [from [nth] mixing bowl].\*(C'\fR
.Sp
This subtracts the value of ingredient from the value of the ingredient
on top of the nth mixing bowl and stores the result in the nth mixing bowl.
.IP "\(bu" 2
\&\f(CW\*(C`Combine ingredient [into [nth] mixing bowl].\*(C'\fR
.Sp
This multiplies the value of ingredient by the value of the ingredient on
top of the nth mixing bowl and stores the result in the nth mixing bowl.
.IP "\(bu" 2
\&\f(CW\*(C`Divide ingredient [into [nth] mixing bowl].\*(C'\fR
.Sp
This divides the value of ingredient into the value of the ingredient on
top of the nth mixing bowl and stores the result in the nth mixing bowl.
.IP "\(bu" 2
\&\f(CW\*(C`Add dry ingredients [to [nth] mixing bowl].\*(C'\fR
.Sp
This adds the values of all the dry ingredients together and places the
result into the nth mixing bowl.
.IP "\(bu" 2
\&\f(CW\*(C`Liquify ingredient.\*(C'\fR
.Sp
This turns the ingredient into a liquid, i.e. a Unicode character for
output purposes.
.IP "\(bu" 2
\&\f(CW\*(C`Liquify contents of the [nth] mixing bowl.\*(C'\fR
.Sp
This turns all the ingredients in the nth mixing bowl into a liquid, i.e.
a Unicode characters for output purposes.
.IP "\(bu" 2
\&\f(CW\*(C`Stir [the [nth] mixing bowl] for number minutes.\*(C'\fR
.Sp
This \*(L"rolls\*(R" the top number ingredients in the nth mixing bowl, such that
the top ingredient goes down that number of ingredients and all
ingredients above it rise one place. If there are not that many ingredients
in the bowl, the top ingredient goes to tbe bottom of the bowl and all the
others rise one place.
.IP "\(bu" 2
\&\f(CW\*(C`Stir ingredient into the [nth] mixing bowl.\*(C'\fR
.Sp
This rolls the number of ingredients in the nth mixing bowl equal to the
value of ingredient, such that the top ingredient goes down that number of
ingredients and all ingredients above it rise one place. If there are not
that many ingredients in the bowl, the top ingredient goes to tbe bottom
of the bowl and all the others rise one place.
.IP "\(bu" 2
\&\f(CW\*(C`Mix [the [nth] mixing bowl] well.\*(C'\fR
.Sp
This randomises the order of the ingredients in the nth mixing bowl.
.IP "\(bu" 2
\&\f(CW\*(C`Clean [nth] mixing bowl.\*(C'\fR
.Sp
This removes all the ingredients from the nth mixing bowl.
.IP "\(bu" 2
\&\f(CW\*(C`Pour contents of the [nth] mixing bowl into the [pth] baking dish.\*(C'\fR
.Sp
This copies all the ingredients from the nth mixing bowl to the pth baking
ish, retaining the order and putting them on top of anything already in
the baking dish.
.IP "\(bu" 2
\&\f(CW\*(C`Verb the ingredient.\*(C'\fR
.Sp
This marks the beginning of a loop. It must appear as a matched pair with
the following statement. The loop executes as follows: The value of
ingredient is checked. If it is non-zero, the body of the loop executes
until it reaches the \*(L"until\*(R" statement. The value of ingredient is
rechecked. If it is non-zero, the loop executes again. If at any check
the value of ingredient is zero, the loop exits and execution continues
at the statement after the \*(L"until\*(R". Loops may be nested.
.IP "\(bu" 2
\&\f(CW\*(C`Verb [the ingredient] until verbed.\*(C'\fR
.Sp
This marks the end of a loop. It must appear as a matched pair with the
above statement. verbed must match the Verb in the matching loop start
statement. The Verb in this statement may be arbitrary and is ignored.
If the ingredient appears in this statement, its value is decremented
by 1 when this statement executes. The ingredient does not have to
match the ingredient in the matching loop start statement.
.IP "\(bu" 2
\&\f(CW\*(C`Set aside.\*(C'\fR
.Sp
This causes execution of the innermost loop in which it occurs to end
immediately and execution to continue at the statement after the \*(L"until\*(R".
.IP "\(bu" 2
\&\f(CW\*(C`Serve with auxiliary\-recipe.\*(C'\fR
.Sp
This invokes a sous-chef to immediately prepare the named auxiliary-recipe.
The calling chef waits until the sous-chef is finished before continuing.
See the section on auxiliary recipes below.
.IP "\(bu" 2
\&\f(CW\*(C`Refrigerate [for number hours].\*(C'\fR
.Sp
This causes execution of the recipe in which it appears to end immediately.
If in an auxiliary recipe, the auxiliary recipe ends and the sous-chef's
first mixing bowl is passed back to the calling chef as normal. If a number
of hours is specified, the recipe will print out its first number baking
dishes (see the Serves statement below) before ending.
.SS "Serves"
.IX Subsection "Serves"
The final statement in a Chef recipe is a statement of how many people
it serves.
.PP
.Vb 1
\&  Serves number\-of\-diners.
.Ve
.PP
This statement writes to \s-1STDOUT\s0 the contents of the first number-of-diners
baking dishes. It begins with the 1st baking dish, removing values from the
top one by one and printing them until the dish is empty, then progresses to
the next dish, until all the dishes have been printed. The serves statement
is optional, but is required if the recipe is to output anything!
.SS "Auxiliary Recipes"
.IX Subsection "Auxiliary Recipes"
These are small recipes which are needed to produce specialised ingredients
for the main recipe (such as sauces). They are listed after the main recipe.
Auxiliary recipes are made by sous-chefs, so they have their own set of
mixing bowls and baking dishes which the head Chef never sees, but take
copies of all the mixing bowls and baking dishes currently in use by the
calling chef when they are called upon. When the auxiliary recipe is
finished, the ingredients in its first mixing bowl are placed in the same
order into the calling chef's first mixing bowl.
.PP
For example, the main recipe calls for a sauce at some point. The sauce
recipe is begun by the sous-chef with an exact copy of all the calling
chef's mixing bowls and baking dishes. Changes to these bowls and dishes
do not affect the calling chef's bowls and dishes. When the sous-chef is
finished, he passes his first mixing bowl back to the calling chef, who
empties it into his first mixing bowl.
.PP
An auxiliary recipe may have all the same items as a main recipe.
.SH "BUGS"
.IX Header "BUGS"
A lot. This is a boring night's result.
.PP
In particular, the implementation does not always comply to the specification.
While this is admittedly very bad behaviour, the author claims in defense that
it usually allows a broader syntax than the specification so you should be safe
when sticking to the specification.
.SH "AUTHOR"
.IX Header "AUTHOR"
Steffen Mueller.
.PP
Chef was designed by David Morgan-Mar.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2002\-2008 Steffen Mueller. All rights reserved. This program is
free software; you can redistribute it and/or modify it under the same
terms as Perl itself.
.PP
Author can be reached at chef-module at steffen-mueller dot net
